"""
This script generates performance graphs based on simulation results. It reads CSV files generated by 
SyntheticImages_SlidingImages_separate2STEDs_2species_1controlforall_generalize_looppowers and 
SyntheticImages_SlidingImages_separate2STEDs_3species _LinesFromControls_generalize_looppowers
containing metrics of unmixed simulation images, such as resolution and SQUIRREL.
 The script groups the metrics by condition such as depletion power and fractions and plots the results using matplotlib and seaborn. 
 The script also calculates the significance of the differences between the metrics of the two conditions.
"""


# -*- coding: utf-8 -*-
import os.path
from sys import path as path1;
#path1.append('/Users/marielafontaine/Documents/GitHub/Abberior-STED-FLIM/Functions')
dossier = os.path.expanduser("~/Documents/Github/Abberior-STED-FLIM/Functions")
path1.append(dossier)
import functools
from statistics_functions import get_significance
import matplotlib.pyplot as plt
import numpy
import glob
import itertools
import tifffile
from mpl_toolkits.axes_grid1 import make_axes_locatable
from matplotlib.gridspec import GridSpec
import matplotlib.patches as mpatches
import seaborn
import pandas as pd
import scipy
from sklearn.linear_model import LinearRegression
import sklearn
import skimage
import matplotlib
matplotlib.rcParams['axes.linewidth'] = 0.8
offsetin=[-4,4]
offsetout=[-2,2]
labels=["2species","3species"]

# Paths to the folders containing the CSV files


folder1=os.path.join("C:",os.sep,"Users","ANDES399","Desktop","Simulation_CY5_SpectrinBassoon","2Species")
folder2=os.path.join("C:",os.sep,"Users","ANDES399","Desktop","Simulation_CY5_SpectrinBassoon","3Species")

folders=[folder1,folder2]
print(folders)


def STEDRes(x, a, b):
    """
    Calculate the STED resolution based on the given parameters.Used to fit resolution as a function of depletion power

    Parameters:
    x (float): The depletion power
    a (float): Parameter alpha
    b (float): Parameter Dc

    Returns:
    float: The calculated STED resolution.

    """
    return a / numpy.sqrt(1 + (a ** 2 * b ** 2 * x))

def monoExp(x, m, t, b):
    """
    Calculates the value of a monotonically decreasing exponential function at a given point.

    Parameters:
    x (float): The input value.
    m (float): The coefficient multiplying the exponential term.
    t (float): The time constant of the exponential decay.
    b (float): The constant offset.

    Returns:
    float: The value of the monotonically decreasing exponential function at the given point.
    """
    return m * numpy.exp(-t * x) + b
# Create the figure and axes
figoverall1, axoverall1 = plt.subplots(figsize=(7, 5))
figoverall2, axoverall2 = plt.subplots(figsize=(7, 5))
figoverall7, axoverall7 = plt.subplots(figsize=(3,3))
figoverall8, axoverall8 = plt.subplots(figsize=(3,3))
figoverall9, axoverall9 = plt.subplots(figsize=(7, 5))
figoverall10, axoverall10 = plt.subplots(figsize=(7, 5))
figoverall11, axoverall11 = plt.subplots(figsize=(7, 5))
figoverall3, axoverall3 = plt.subplots(figsize=(7, 5))
figoverall4, axoverall4 = plt.subplots(figsize=(7, 5))
figoverall5, axoverall5 = plt.subplots(figsize=(7, 5))
figoverall6, axoverall6 = plt.subplots(figsize=(7, 5))
Fig, Ax = plt.subplots(nrows=2,ncols=2,figsize=(4,4),sharex=True,sharey='row')
Fig1, Ax1 = plt.subplots(nrows=2,ncols=2,figsize=(4,4),sharex=True,sharey='row')
Fig2, Ax2 = plt.subplots(nrows=1,ncols=3,figsize=(6,2),sharex=True,sharey='row')


# Set the labels and ticks
mwpowers=["44","88","132","176"]
Ax[0,0].set_ylim([25, 320])
Ax[0,1].set_ylim([25, 320])
Ax[0,0].tick_params(axis ='both',length=2, width=0.8)
Ax[0,1].tick_params(axis ='both',length=2, width=0.8)
Ax[1,0].tick_params(axis ='both',length=2, width=0.8)
Ax[1,1].tick_params(axis ='both',length=2, width=0.8)
Ax[0,1].set_xticks([10,20,30,40])
Ax[0,1].set_xticklabels(mwpowers,fontsize=16)

Ax1[0,0].set_ylim([25, 320])
Ax1[0,1].set_ylim([25, 320])
Ax1[0,0].tick_params(axis ='both',length=2, width=0.8)
Ax1[0,1].tick_params(axis ='both',length=2, width=0.8)
Ax1[1,0].tick_params(axis ='both',length=2, width=0.8)
Ax1[1,1].tick_params(axis ='both',length=2, width=0.8)
Ax1[0,1].set_xticks([10,20,30,40])
Ax1[0,1].set_xticklabels(mwpowers,fontsize=16)

Ax2[0].set_ylim([25, 320])
Ax2[1].set_ylim([25, 320])
Ax2[0].tick_params(axis ='both',length=2, width=0.8)
Ax2[1].tick_params(axis ='both',length=2, width=0.8)
Ax2[2].tick_params(axis ='both',length=2, width=0.8)

Ax2[0].set_xticks([10,20,30,40])
Ax2[0].set_xticklabels(mwpowers)

cumdf=[]
csvfull=[]
# Loop over the folders containing the CSV files and pool the data into a single dataframe.
for i,folder in enumerate(folders):
    colors = ["xkcd:peacock blue", "xkcd:brick orange"]
    colors = ["cyan","magenta","gold"]
    csvlist=glob.glob(os.path.join(folder,"*","*.csv"))


    Overall_data= pd.concat(map(pd.read_csv, csvlist))
    cumdf.append(Overall_data)

    print(Overall_data.shape)
    print(list(Overall_data.columns))
    print(Overall_data)

    #["_30",[0,4]],["30",[0,0]],["40",[0,0]]


    globalcumstats=[]
    globalcumstatsmean=[]
    globalcumstatsstd=[]
    globalcumstatssem= []
    row=0
    # Group the data in the dataframe by depletion powers and calculate the mean, standard deviation and standard error of the mean of the metrics.
    Mean_Power=Overall_data.groupby(by=["Power"]).mean(numeric_only=True).reset_index()
    STD_Power=Overall_data.groupby(by=["Power"]).std().reset_index()
    SEM_Power = Overall_data.groupby(by=["Power"]).sem().reset_index()


    # Extract the important metric statistics from the dataframe for plotting
    if i==1:
        globalcumstats=numpy.array([Overall_data["Power"],Overall_data["resolution2"],Overall_data["resolution1"],Overall_data["res_fraction1"],Overall_data["res_fraction2"],Overall_data["res_fraction3"],Overall_data["squirrel_f1"],Overall_data["squirrel_f2"]])
        cumstatsmean=numpy.array([Mean_Power["Power"],Mean_Power["resolution2"],Mean_Power["resolution1"],Mean_Power["res_fraction1"],Mean_Power["res_fraction2"],Mean_Power["res_fraction3"],Mean_Power["squirrel_f1"],Mean_Power["squirrel_f2"]])
        cumstatsstd=numpy.array([STD_Power["Power"],STD_Power["resolution2"],STD_Power["resolution1"],STD_Power["res_fraction1"],STD_Power["res_fraction2"],STD_Power["res_fraction3"],STD_Power["squirrel_f1"],STD_Power["squirrel_f2"]])
        cumstatssem=numpy.array([SEM_Power["Power"],SEM_Power["resolution2"],SEM_Power["resolution1"],SEM_Power["res_fraction1"],SEM_Power["res_fraction2"],SEM_Power["res_fraction3"],SEM_Power["squirrel_f1"],SEM_Power["squirrel_f2"]])

    if i==0:
        globalcumstats=numpy.array([Overall_data["Power"],Overall_data["resolution2"],Overall_data["resolution1"],Overall_data["res_fraction1"],Overall_data["res_fraction2"],Overall_data["res_fraction2"],Overall_data["squirrel_f1"],Overall_data["squirrel_f2"]])
        cumstatsmean=numpy.array([Mean_Power["Power"],Mean_Power["resolution2"],Mean_Power["resolution1"],Mean_Power["res_fraction1"],Mean_Power["res_fraction2"],Mean_Power["res_fraction2"],Mean_Power["squirrel_f1"],Mean_Power["squirrel_f2"]])
        cumstatsstd=numpy.array([STD_Power["Power"],STD_Power["resolution2"],STD_Power["resolution1"],STD_Power["res_fraction1"],STD_Power["res_fraction2"],STD_Power["res_fraction2"],STD_Power["squirrel_f1"],STD_Power["squirrel_f2"]])
        cumstatssem=numpy.array([SEM_Power["Power"],SEM_Power["resolution2"],SEM_Power["resolution1"],SEM_Power["res_fraction1"],SEM_Power["res_fraction2"],SEM_Power["res_fraction2"],SEM_Power["squirrel_f1"],SEM_Power["squirrel_f2"]])

    print("GCS",globalcumstats.shape)


    powers = numpy.unique(Overall_data["Power"])
    x = powers
    xs = numpy.linspace(numpy.min(x), numpy.max(x), (numpy.max(x) - numpy.min(x)).astype(int))
    if i==1:
        # Plot the resolution metrics for fraction 3 of the 2species SPLIT-STED method and fit the data to a monotonically decreasing exponential function

        Ax[0,1].errorbar(x=Mean_Power["Power"], y=Mean_Power["res_fraction3"], yerr=STD_Power["res_fraction3"], fmt="o",
                       c=colors[2], label='SPLIT Fraction3', ecolor=colors[2], capsize=3.5, elinewidth=0.8, ms=3.5)
        Ax1[0,1].errorbar(x=Mean_Power["Power"], y=Mean_Power["res_fraction3"], yerr=SEM_Power["res_fraction3"], fmt="o",
                       c=colors[2], label='SPLIT Fraction3', ecolor=colors[2], capsize=3.5, elinewidth=0.8, ms=3.5)
        Ax2[1].errorbar(x=Mean_Power["Power"], y=Mean_Power["res_fraction3"], yerr=SEM_Power["res_fraction3"], fmt="o",
                       c=colors[2], label='SPLIT Fraction3', ecolor=colors[2], capsize=3.5, elinewidth=0.8, ms=3.5)
        
        Ax2[2].errorbar(x=Mean_Power["Power"], y=Mean_Power["resolution1"], yerr=SEM_Power["resolution1"], fmt="o",
                c=colors[0], label='STED input 1', ecolor=colors[0], capsize=3.5, elinewidth=0.8, ms=3.5)
        Ax2[2].errorbar(x=Mean_Power["Power"], y=Mean_Power["resolution2"], yerr=SEM_Power["resolution2"], fmt="o",
                   c=colors[1], label='STED input 2', ecolor=colors[1],capsize=3.5, elinewidth=0.8, ms=3.5)

        try:
            params, cv = scipy.optimize.curve_fit(monoExp, Overall_data["Power"], Overall_data["res_fraction3"],
                                                  maxfev=10000)
            m, t, b = params
            y_pred = monoExp(Overall_data["Power"], m,t,b)
            rsquared=sklearn.metrics.r2_score(Overall_data["res_fraction3"], y_pred)
            Ax[0,1].plot(xs, monoExp(xs, m, t, b), '-', c=colors[2],linewidth=0.8)
            Ax1[0, 1].plot(xs, monoExp(xs, m, t, b), '-', c=colors[2], linewidth=0.8)
            Ax2[ 1].plot(xs, monoExp(xs, m, t, b), '-', c=colors[2], linewidth=0.8)
            print("SPLIT Fraction3")
            print("Parameters:\nA={0:.3g}\nt={1:.4g}\nb={2:.3g}\n".format(m, t, b))
            print("r2={}".format(rsquared))

            params, cv = scipy.optimize.curve_fit(STEDRes, Overall_data["Power"], Overall_data["resolution1"],
                                                  maxfev=10000)
            a, b = params
            y_pred =STEDRes(Overall_data["Power"], a,b)
            rsquared=sklearn.metrics.r2_score(Overall_data["resolution1"], y_pred)
            print("Resolution input 1")
            print("Parameters:\nalpha={0:.3g}\nDc={1:.4g}\n".format(a,b))
            print("r2={}".format(rsquared))
            Ax2[2].plot(xs,STEDRes(xs, a, b), '-', c=colors[0], linewidth=0.8)
            params, cv = scipy.optimize.curve_fit(STEDRes, Overall_data["Power"], Overall_data["resolution2"],
                                                  maxfev=10000)
            
            a, b = params
            y_pred =STEDRes(Overall_data["Power"], a,b)
            rsquared=sklearn.metrics.r2_score(Overall_data["resolution2"], y_pred)
            print("Resolution input 2")
            print("Parameters:\nalpha={0:.3g}\nDc={1:.4g}\n".format(a,b))
            print("r2={}".format(rsquared))
            Ax2[2].plot(xs,STEDRes(xs, a, b), '-', c=colors[1], linewidth=0.8)
            #Ax[0,1].text(0, 0, "Parameters:\nA={0:.3g}\nt={1:.4g}\nb={2:.3g}".format(m, t, b), c=colors[i], fontsize=16)
        except RuntimeError:
            print("Fit didn't work")
# Plot the resolution metrics for fraction 1 and 2 of the 2species SPLIT-STED and STED-FLIM method and fit the data to a monotonically decreasing exponential function
    Ax[0,i].errorbar(x=Mean_Power["Power"], y=Mean_Power["res_fraction2"], yerr=STD_Power["res_fraction2"], fmt="o",
                c=colors[0], label='STED Fraction1', ecolor=colors[0], capsize=3.5, elinewidth=0.8, ms=3.5)
    Ax[0,i].errorbar(x=Mean_Power["Power"], y=Mean_Power["res_fraction1"], yerr=STD_Power["res_fraction1"], fmt="o",
                   c=colors[1], label='STED Fraction2', ecolor=colors[1],capsize=3.5, elinewidth=0.8, ms=3.5)

    Ax1[0,i].errorbar(x=Mean_Power["Power"], y=Mean_Power["res_fraction2"], yerr=SEM_Power["res_fraction2"], fmt="o",
                c=colors[0], label='STED Fraction1', ecolor=colors[0], capsize=3.5, elinewidth=0.8, ms=3.5)
    Ax1[0,i].errorbar(x=Mean_Power["Power"], y=Mean_Power["res_fraction1"], yerr=SEM_Power["res_fraction1"], fmt="o",
                   c=colors[1], label='STED Fraction2', ecolor=colors[1],capsize=3.5, elinewidth=0.8, ms=3.5)


    Ax2[i].errorbar(x=Mean_Power["Power"], y=Mean_Power["res_fraction2"], yerr=SEM_Power["res_fraction2"], fmt="o",
                c=colors[0], label='STED Fraction1', ecolor=colors[0], capsize=3.5, elinewidth=0.8, ms=3.5)
    Ax2[i].errorbar(x=Mean_Power["Power"], y=Mean_Power["res_fraction1"], yerr=SEM_Power["res_fraction1"], fmt="o",
                   c=colors[1], label='STED Fraction2', ecolor=colors[1],capsize=3.5, elinewidth=0.8, ms=3.5)

    try:
        params, cv = scipy.optimize.curve_fit(monoExp, Overall_data["Power"], Overall_data["res_fraction1"], maxfev=10000)
        m, t, b = params
        y_pred = monoExp(Overall_data["Power"], m,t,b)
        rsquared=sklearn.metrics.r2_score(Overall_data["res_fraction1"], y_pred)
        Ax[0,i].plot(xs, monoExp(xs, m, t, b), '-', c=colors[1],linewidth=0.8)
        Ax1[0, i].plot(xs, monoExp(xs, m, t, b), '-', c=colors[1], linewidth=0.8)
        Ax2[ i].plot(xs, monoExp(xs, m, t, b), '-', c=colors[1], linewidth=0.8)
        #Ax[0,0].text(0, 125, "Parameters:\nA={0:.3g}\nt={1:.4g}\nb={2:.3g}".format(m, t, b), c=colors[i], fontsize=16)
        print("Resolution Fraction 1 " ,labels[i])
        print("Parameters:\nA={0:.3g}\nt={1:.4g}\nb={2:.3g}".format(m, t, b))
        print("r2={}".format(rsquared))
        params, cv = scipy.optimize.curve_fit(monoExp, Overall_data["Power"], Overall_data["res_fraction2"], maxfev=10000)
        m, t, b = params
        y_pred = monoExp(Overall_data["Power"], m,t,b)
        rsquared=sklearn.metrics.r2_score(Overall_data["res_fraction2"], y_pred)
        Ax[0,i].plot(xs, monoExp(xs, m, t, b), '-', c=colors[0],linewidth=0.8)
        Ax1[0, i].plot(xs, monoExp(xs, m, t, b), '-', c=colors[0], linewidth=0.8)
        Ax2[i].plot(xs, monoExp(xs, m, t, b), '-', c=colors[0], linewidth=0.8)
        #Ax[0,1].text(0, 125, "Parameters:\nA={0:.3g}\nt={1:.4g}\nb={2:.3g}".format(m, t, b), c=colors[i], fontsize=16)
        print("Resolution Fraction 2 ", labels[i])
        print("Parameters:\nA={0:.3g}\nt={1:.4g}\nb={2:.3g}".format(m, t, b))
        print("r2={}".format(rsquared))
    except RuntimeError:
        print("Fit didn't work")
# Plot the Squirrel metrics for fraction 1 and 2 of the 2species SPLIT-STED and STED-FLIM method
    Ax[1,i].errorbar(x=Mean_Power["Power"], y=Mean_Power["squirrel_f1"], yerr=STD_Power["squirrel_f1"], fmt="o",
                c=colors[0], label='STED Fraction1', ecolor=colors[0], capsize=3.5, elinewidth=0.8, ms=3.5)
    Ax[1,i].errorbar(x=Mean_Power["Power"], y=Mean_Power["squirrel_f2"], yerr=STD_Power["squirrel_f2"], fmt="o",
                   c=colors[1], label='STED Fraction2', ecolor=colors[1], capsize=3.5, elinewidth=0.8, ms=3.5)

    Ax1[1,i].errorbar(x=Mean_Power["Power"], y=Mean_Power["squirrel_f1"], yerr=SEM_Power["squirrel_f1"], fmt="o",
                c=colors[0], label='STED Fraction1', ecolor=colors[0], capsize=3.5, elinewidth=0.8, ms=3.5)
    Ax1[1,i].errorbar(x=Mean_Power["Power"], y=Mean_Power["squirrel_f2"], yerr=SEM_Power["squirrel_f2"], fmt="o",
                   c=colors[1], label='STED Fraction2', ecolor=colors[1], capsize=3.5, elinewidth=0.8, ms=3.5)


    cumstats=globalcumstats
    print("cumstatsmean", cumstatsmean.shape)
    powers=numpy.unique(cumstats[0,:])
    print(numpy.unique(cumstats[0,:])+offsetin[i])

    colors = [['lightsteelblue', 'deepskyblue', 'royalblue', 'midnightblue'],
              ['lightsalmon', 'lightcoral', 'crimson', 'darkred', 'springgreen']]



# Create violin plots for the resolution and Squirrel metrics of the 2species SPLIT-STED and STED-FLIM methods


    axoverall4.violinplot([cumstats[3,:][cumstats[0,:]==power] for power in powers],numpy.unique(cumstats[0,:])+offsetin[i],widths=2,showmeans=True)
    axoverall4.scatter(cumstats[0,:]+offsetin[i],cumstats[3,:],label="Resolution Fraction 1 "+labels[i])
    if i==0:
        axoverall4.violinplot([cumstats[1, :][cumstats[0, :] == power] for power in powers],
                              numpy.unique(cumstats[0, :]) , widths=2,showmeans=True)
        axoverall4.scatter(cumstats[0, :] , cumstats[1, :], label="Resolution Fraction 1 Input" )
    axoverall4.legend()
    axoverall4.set_ylim([0, 300])


    axoverall5.violinplot([cumstats[4,:][cumstats[0,:]==power] for power in powers],numpy.unique(cumstats[0,:])+offsetout[i],widths=2,showmeans=True)
    axoverall5.scatter(cumstats[0,:]+offsetout[i],cumstats[4,:], label ="Resolution Fraction 2 "+labels[i])
    if i==0:
        axoverall5.violinplot([cumstats[2, :][cumstats[0, :] == power] for power in powers],
                              numpy.unique(cumstats[0, :]) , widths=2,showmeans=True)
        axoverall5.scatter(cumstats[0, :] , cumstats[2, :], label="Resolution Fraction 2 Input" )
    if i==1:
        axoverall5.violinplot([cumstats[5,:][cumstats[0,:]==power] for power in powers],numpy.unique(cumstats[0,:])+offsetout[i],widths=2,showmeans=True)
        axoverall5.scatter(cumstats[0,:]+offsetout[i],cumstats[5,:], label ="Resolution Fraction 3 "+labels[i])
    axoverall5.legend()
    axoverall5.set_ylim([0, 300])

    meanoutput = numpy.mean(cumstats[3:5, :], axis=0)
    axoverall6.violinplot([meanoutput[cumstats[0,:]==power] for power in powers],numpy.unique(cumstats[0,:])+offsetout[i],widths=2,showmeans=True)
    axoverall6.scatter(cumstats[0,:]+offsetout[i],meanoutput, label ="Resolution Output "+labels[i])
    if i==0:
        meaninput = numpy.mean(cumstats[1:3, :], axis=0)
        axoverall6.violinplot([meaninput[cumstats[0, :] == power] for power in powers],
                              numpy.unique(cumstats[0, :]) , widths=2,showmeans=True)
        axoverall6.scatter(cumstats[0, :], meaninput, label="Resolution Input" )
    axoverall6.legend()
    axoverall6.set_ylim([0, 300])

    axoverall3.violinplot([cumstats[6, :][cumstats[0, :] == power] for power in powers],
                          numpy.unique(cumstats[0, :]) + offsetin[i], widths=2,showmeans=True)
    axoverall3.violinplot([cumstats[7, :][cumstats[0, :] == power] for power in powers],
                          numpy.unique(cumstats[0, :]) + offsetout[i], widths=2,showmeans=True)
    axoverall3.scatter(cumstats[0,:]+offsetin[i],cumstats[6,:],label="Squirrel Fraction 1 "+labels[i])
    axoverall3.scatter(cumstats[0,:]+offsetout[i],cumstats[7,:], label =" Squirrel Fraction 2 "+labels[i])
    axoverall3.legend()


Overall_data= pd.concat([df.assign(identity=k) for k,df in zip(labels,cumdf)])
print(Overall_data.shape)

Mean_Power = Overall_data.groupby(by=["Power"]).mean(numeric_only=True).reset_index()
STD_Power = Overall_data.groupby(by=["Power"]).std().reset_index()
print(list(Overall_data.columns))
resmeanout=Overall_data[["res_fraction1","res_fraction2"]].mean(axis=1).values
resmeanin=Overall_data[["resolution1","resolution2"]].mean(axis=1).values
print(resmeanin.shape)
print(resmeanout.shape)
axoverall1.set_title("res_fraction1")
axoverall2.set_title("res_fraction2")
axoverall9.set_title("resolution1")
axoverall10.set_title("resolution2")
seaborn.violinplot(data=Overall_data,x=Overall_data["Power"],y=Overall_data["res_fraction1"],hue="identity",ax=axoverall1,width=0.55)
seaborn.violinplot(data=Overall_data,x=Overall_data["Power"],y=Overall_data["res_fraction3"],hue="identity",ax=axoverall11,width=0.55)
seaborn.violinplot(data=Overall_data,x=Overall_data["Power"],y=Overall_data["res_fraction2"],hue="identity",ax=axoverall2,width=0.55)
seaborn.violinplot(data=Overall_data,x=Overall_data["Power"],y=Overall_data["resolution2"],hue="identity",ax=axoverall9,width=0.55)
seaborn.violinplot(data=Overall_data,x=Overall_data["Power"],y=Overall_data["resolution1"],hue="identity",ax=axoverall10,width=0.55)
axoverall1.set_ylim([-10, 450])
axoverall2.set_ylim([-10, 450])
axoverall9.set_ylim([-10, 450])
axoverall10.set_ylim([-10, 450])
axoverall11.set_ylim([-10, 450])
squirrelmean=Overall_data[["squirrel_f1","squirrel_f2"]].mean(axis=1)

print(squirrelmean.shape)

seaborn.violinplot(data=Overall_data,x=Overall_data["Power"],y=Overall_data["squirrel_f1"],hue="identity",inner="quart",split=True,ax=axoverall7,width=0.8)
seaborn.violinplot(data=Overall_data,x=Overall_data["Power"],y=Overall_data["squirrel_f2"],hue="identity",inner="quart",split=True,ax=axoverall8,width=0.8)
#axoverall7.set_title("squirrel_f1")
#axoverall8.set_title("squirrel_f2")
axoverall7.set_ylim([-0.0005,0.00475])
axoverall8.set_ylim([-0.0005,0.00475])

# Statistical analysis of the differences between the metrics of the two conditions
methods=numpy.unique(Overall_data["identity"])
print(methods)
print("#############################################################################################################")

for power in powers:
    print("Squirrel F1 Power",power)
    sig=get_significance([Overall_data["squirrel_f1"][(Overall_data["identity"]==method) & (Overall_data["Power"] ==power)] for method in methods], verbose=True)
    print("sig",sig)
print("############################################################################################################")
for power in powers:
    print("Squirrel F2 Power",power)
    sig=get_significance([Overall_data["squirrel_f2"][(Overall_data["identity"]==method) & (Overall_data["Power"] ==power)] for method in methods], verbose=True)
    print("sig",sig)

print("############################################################################################################")
for power in powers:
    print("Resolution F1 Power",power)
    outres=[Overall_data["res_fraction1"][(Overall_data["identity"]==method) & (Overall_data["Power"] ==power)] for method in methods]

    inres=Overall_data["resolution2"][(Overall_data["identity"]==methods[0]) & (Overall_data["Power"] ==power)]
    outres.append(inres)

    sig=get_significance(outres, verbose=True)
    print("sig",sig)
print("#############################################################################################################")
for power in powers:
    print("Resolution F2 Power",power)
    outres=[Overall_data["res_fraction2"][(Overall_data["identity"]==method) & (Overall_data["Power"] ==power)] for method in methods]

    inres=Overall_data["resolution1"][(Overall_data["identity"]==methods[0]) & (Overall_data["Power"] ==power)]
    outres.append(inres)

    sig=get_significance(outres, verbose=True)
    print("sig",sig)

axoverall1.legend()

# Save the figures and close the plots
figoverall1.savefig('Resolution_F1_Violin.pdf', transparent='True', bbox_inches="tight")
figoverall11.savefig('Resolution_F3_Violin.pdf', transparent='True', bbox_inches="tight")
figoverall7.savefig('Squirrel_F1_Violin.pdf', transparent='True', bbox_inches="tight")
figoverall8.savefig('Squirrel_F2_Violin.pdf', transparent='True', bbox_inches="tight")
figoverall2.savefig('Resolution_F2_Violin.pdf', transparent='True', bbox_inches="tight")
figoverall10.savefig('Resolution_Input2_Violin.pdf', transparent='True', bbox_inches="tight")
figoverall9.savefig('Resolution_Input1_Violin.pdf', transparent='True', bbox_inches="tight")
Fig.savefig('Resolution_Squirrel_stderrorbars_fit.pdf', transparent='True', bbox_inches="tight")
Fig1.savefig('Resolution_Squirrel_semerrorbars_fit.pdf', transparent='True', bbox_inches="tight")
Fig2.savefig('Resolution_input_2methods_semerrorbars_fit.pdf', transparent='True', bbox_inches="tight")
plt.close(figoverall1)
plt.close(figoverall11)
plt.close(figoverall10)
plt.close(figoverall2)
plt.close(figoverall9)
plt.close(figoverall3)
plt.close(figoverall4)
plt.close(figoverall5)
plt.close(figoverall6)


plt.show()

